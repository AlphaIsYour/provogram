/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */
// app/[username]/achievements/page.tsx

import prisma from "@/lib/prisma";
import { notFound } from "next/navigation";
import Image from "next/image";
import Link from "next/link";
import {
  ArrowLeft,
  Award,
  Trophy,
  Medal,
  Star,
  Target,
  Zap,
  Crown,
  Shield,
  Flame,
  Users,
  BookOpen,
  Code,
  Heart,
  TrendingUp,
  CheckCircle2,
  Calendar,
  Clock,
  Gift,
  Sparkles,
  BadgeCheck,
  MapPin,
  Globe,
  Coffee,
  Lightbulb,
  Brain,
  Rocket,
  Diamond,
  Gem,
} from "lucide-react";

// Icon mapping helper
const getIconComponent = (iconName: string) => {
  const iconMap: { [key: string]: any } = {
    Code,
    Flame,
    Users,
    Rocket,
    Crown,
    Zap,
    Brain,
    Shield,
    Coffee,
    Lightbulb,
    Diamond,
    Globe,
    Trophy,
    Medal,
    Star,
    Target,
    Award,
    Heart,
    BookOpen,
    Gift,
    Gem,
  };
  return iconMap[iconName] || Trophy;
};

export default async function AchievementsPage({
  params,
}: {
  params: Promise<{ username: string }>;
}) {
  // Await the params Promise
  const { username } = await params;

  // Fetch user with related data
  const user = await prisma.user.findUnique({
    where: {
      username: username,
    },
    include: {
      userAchievements: {
        include: {
          achievement: {
            include: {
              category: true,
            },
          },
        },
        orderBy: {
          earnedAt: "desc",
        },
      },
      activityLogs: {
        where: {
          type: "ACHIEVEMENT_EARNED",
        },
        orderBy: {
          createdAt: "desc",
        },
        take: 10,
      },
    },
  });

  if (!user) {
    notFound();
  }

  // Fetch all available achievements
  const allAchievements = await prisma.achievement.findMany({
    include: {
      category: true,
      awardedTo: {
        where: {
          userId: user.id,
        },
      },
    },
    orderBy: {
      xp: "desc",
    },
  });

  // Calculate achievement stats
  const earnedAchievements = user.userAchievements.filter((ua) => ua.earnedAt);
  const rareAchievements = earnedAchievements.filter(
    (ua) =>
      ua.achievement.rarity === "EPIC" || ua.achievement.rarity === "LEGENDARY"
  );

  const achievementStats = {
    totalBadges: earnedAchievements.length,
    rareAchievements: rareAchievements.length,
    currentStreak: user.streak,
    totalXP: user.totalXp,
    rank: user.communityRank || "#-",
    level: user.level,
  };

  // Get categories with counts
  const categoryStats = await prisma.category.findMany({
    include: {
      achievements: {
        include: {
          awardedTo: {
            where: {
              userId: user.id,
              earnedAt: { not: null },
            },
          },
        },
      },
    },
  });

  const categories = [
    {
      name: "All",
      count: earnedAchievements.length,
      active: true,
    },
    ...categoryStats.map((cat) => ({
      name: cat.name,
      count: cat.achievements.filter((a) => a.awardedTo.length > 0).length,
      active: false,
    })),
  ];

  // Transform achievements data
  const achievements = allAchievements.map((achievement) => {
    const userAchievement = achievement.awardedTo[0];
    const isEarned =
      userAchievement?.earnedAt !== null &&
      userAchievement?.earnedAt !== undefined;

    return {
      id: achievement.id,
      title: achievement.name,
      description: achievement.description,
      icon: getIconComponent(achievement.icon),
      rarity: achievement.rarity,
      color: achievement.color || "bg-gradient-to-br from-gray-500 to-gray-600",
      textColor: achievement.textColor || "text-gray-400",
      borderColor: achievement.borderColor || "border-gray-500",
      xp: achievement.xp,
      earnedDate:
        userAchievement?.earnedAt?.toISOString().split("T")[0] || null,
      progress: userAchievement?.progress || 0,
      category: achievement.category.name,
      requirements: achievement.requirements,
    };
  });

  const getRarityColor = (rarity: string) => {
    switch (rarity) {
      case "LEGENDARY":
        return "text-purple-400 bg-purple-900/20 border-purple-500";
      case "EPIC":
        return "text-orange-400 bg-orange-900/20 border-orange-500";
      case "RARE":
        return "text-blue-400 bg-blue-900/20 border-blue-500";
      default:
        return "text-gray-400 bg-gray-900/20 border-gray-500";
    }
  };

  const recentAchievements = achievements
    .filter((a) => a.earnedDate)
    .sort(
      (a, b) =>
        new Date(b.earnedDate!).getTime() - new Date(a.earnedDate!).getTime()
    )
    .slice(0, 3);